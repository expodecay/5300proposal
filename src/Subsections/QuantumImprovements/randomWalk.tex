%! Author = rickr
%! Date = 11/27/2021
\subsection{Classical vs Quantum Walk}

Consider the case of a classical random walk. In this example we search for a marked node within a binary tree of size $n$ nodes. 
If we have no indication of where in the tree the target might be, then a sure proof way of finding it is to visit each node, one step at a time, with $50\%$ probability of taking a step to the left and $50\%$ probability of taking a step to the right. 
Naturally, for every step away from the origin, there is an equal probability of taking a step back toward the origin, and over time we will obtain a normal Gaussian distribution of steps as shown in Figure \ref{fig:quantumWalk}. 
The classical random walk distribution exhibits a variance of 
\begin{equation}
	\sigma^2 \propto n
\end{equation}
which is to say that there is a very low probability of hitting the target if it is far away from the origin.
Since  each step is based on a set of definite states, the randomness of the traversal is caused by a stochastic transition between states.
Now consider a random walk in a quantum setting. 
In this case, the randomness comes from the quantum superposition imposed by Equation \ref{eq:spinStates}, a reversible unitary evolution (typically in the form of a Hadamard coin), and a collapse of the wave-function when a measurement is actually taken. 
Another difference between the quantum and classical random walk is the time at which a measurement is taken. 
In the classical version, it makes no difference to take measurements at each iteration, however in the quantum version, if a measurement of the wave-function is taken at each iteration, then the distribution converges to the classical Gaussian form. 
If the wave-function is left to interfere with itself before a measurement is taken, then the probability distribution is much more intricate, as can be seen in Figure \ref{fig:quantumWalk}.
It can be shown the after $n$ steps, the quantum walk obtains a variance of 
\begin{equation}
	\sigma^2 \propto n^2 \quad\cite{kempe2003quantum}
\end{equation}
Therefore, the quantum walk propagates quadratically faster than the classical walk, and this speed increase can be applied to the branch-and-bound framework. 
From Figure \ref{fig:quantumWalk}, if the wave-function is placed in a superposition, then the distribution exhibits destructive interference about the origin.
However, if the wave-function begins in a pure spin-up or spin-down configuration, then it is possible to create a bias toward any particular direction as shown in Figure \ref{fig:biasWalk} of the appendix.
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=13cm]{images/afunc2}
	\end{center}
	\caption{\doublespacing Difference between quantum and classical random walk. The blue dotted line represents the Gaussian distribution created by the classical walk and has a variance $\sigma^2 \propto n$. The black distribution is the result of the quantum random walk where the initial wave-function placed into a superposition $|\Psi\rangle = \alpha|0\rangle + \beta|1\rangle$ and acted on by a balanced Hadamard coin. The quantum distribution exhibits a variance of $\sigma^2 \propto n^2$ with de-constructive interference about the origin and constructive interference at the edges of propagation.}
	\label{fig:quantumWalk}
\end{figure}
\noindent
To summarize the results, consider three individual cases of solving combinatorial problems with Hamiltonians similar to that of Equation \ref{eq:isingHamiltonian}.
One case is solved using classical branch-and-bound techniques, one is solved using quantum walks, and one is solved using branch-and-bound in a quantum setting. 
If the classical branch-and-bound techniques are applied to solve for the largest known ground states of the Beransconi model, the runtime is roughly $O(2^{0.79n})$ \cite{packebusch2016low}. 
If we apply a quantum walk to classical algorithms that solve the Sherrington-Kirkpatrick model (an Ising model with long range anti-ferrmagnetic couplings) then it has been shown we can increase runtime to approximately $O(2^{0.41n})$ \cite{callison2019finding}. 
Finally, by applying quantum branch-and-bound algorithms to the same model, it has been shown that the runtime can be increased further to $O(2^{0.226n})$ \cite{montanaro2020quantum}.